<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Package: runtime</title>
<link href="../css/light-v0.1.8-preview.css" rel="stylesheet">
<script src="../jvs/golds-v0.1.8-preview.js"></script>
<body><div>

<pre><code><span style="font-size:xx-large;">package <b>runtime</b></span>

<span class="title">Import Path</span>
	<a href="../index.html#pkg-runtime">runtime</a><i> (on <a href="https://golang.org/pkg/runtime/" target="_blank">golang.org</a> and <a href="https://pkg.go.dev/runtime" target="_blank">go.dev</a>)</i>

<span class="title">Dependency Relation</span>
	imports <a href="../dep/runtime.html">6 packages</a>, and imported by <a href="../dep/runtime.html#imported-by">6 packages</a>

<span class="title">Involved Source Files</span>
	    <a href="../src/runtime/alg.go.html">alg.go</a>
	    <a href="../src/runtime/atomic_pointer.go.html">atomic_pointer.go</a>
	    <a href="../src/runtime/cgo.go.html">cgo.go</a>
	    <a href="../src/runtime/cgo_mmap.go.html">cgo_mmap.go</a>
	    <a href="../src/runtime/cgo_sigaction.go.html">cgo_sigaction.go</a>
	    <a href="../src/runtime/cgocall.go.html">cgocall.go</a>
	    <a href="../src/runtime/cgocallback.go.html">cgocallback.go</a>
	    <a href="../src/runtime/cgocheck.go.html">cgocheck.go</a>
	    <a href="../src/runtime/chan.go.html">chan.go</a>
	    <a href="../src/runtime/checkptr.go.html">checkptr.go</a>
	    <a href="../src/runtime/compiler.go.html">compiler.go</a>
	    <a href="../src/runtime/complex.go.html">complex.go</a>
	    <a href="../src/runtime/cpuflags.go.html">cpuflags.go</a>
	    <a href="../src/runtime/cpuflags_amd64.go.html">cpuflags_amd64.go</a>
	    <a href="../src/runtime/cpuprof.go.html">cpuprof.go</a>
	    <a href="../src/runtime/cputicks.go.html">cputicks.go</a>
	    <a href="../src/runtime/debug.go.html">debug.go</a>
	    <a href="../src/runtime/debugcall.go.html">debugcall.go</a>
	    <a href="../src/runtime/debuglog.go.html">debuglog.go</a>
	    <a href="../src/runtime/debuglog_off.go.html">debuglog_off.go</a>
	    <a href="../src/runtime/defs_linux_amd64.go.html">defs_linux_amd64.go</a>
	    <a href="../src/runtime/env_posix.go.html">env_posix.go</a>
	    <a href="../src/runtime/error.go.html">error.go</a>
	<a href="../src/runtime/extern.go.html#doc">d-&gt;</a> <a href="../src/runtime/extern.go.html">extern.go</a>
	    <a href="../src/runtime/fastlog2.go.html">fastlog2.go</a>
	    <a href="../src/runtime/fastlog2table.go.html">fastlog2table.go</a>
	    <a href="../src/runtime/float.go.html">float.go</a>
	    <a href="../src/runtime/hash64.go.html">hash64.go</a>
	    <a href="../src/runtime/heapdump.go.html">heapdump.go</a>
	    <a href="../src/runtime/iface.go.html">iface.go</a>
	    <a href="../src/runtime/lfstack.go.html">lfstack.go</a>
	    <a href="../src/runtime/lfstack_64bit.go.html">lfstack_64bit.go</a>
	    <a href="../src/runtime/lock_futex.go.html">lock_futex.go</a>
	    <a href="../src/runtime/lockrank.go.html">lockrank.go</a>
	    <a href="../src/runtime/lockrank_off.go.html">lockrank_off.go</a>
	    <a href="../src/runtime/malloc.go.html">malloc.go</a>
	    <a href="../src/runtime/map.go.html">map.go</a>
	    <a href="../src/runtime/map_fast32.go.html">map_fast32.go</a>
	    <a href="../src/runtime/map_fast64.go.html">map_fast64.go</a>
	    <a href="../src/runtime/map_faststr.go.html">map_faststr.go</a>
	    <a href="../src/runtime/mbarrier.go.html">mbarrier.go</a>
	    <a href="../src/runtime/mbitmap.go.html">mbitmap.go</a>
	    <a href="../src/runtime/mcache.go.html">mcache.go</a>
	    <a href="../src/runtime/mcentral.go.html">mcentral.go</a>
	    <a href="../src/runtime/mem_linux.go.html">mem_linux.go</a>
	    <a href="../src/runtime/mfinal.go.html">mfinal.go</a>
	    <a href="../src/runtime/mfixalloc.go.html">mfixalloc.go</a>
	    <a href="../src/runtime/mgc.go.html">mgc.go</a>
	    <a href="../src/runtime/mgcmark.go.html">mgcmark.go</a>
	    <a href="../src/runtime/mgcscavenge.go.html">mgcscavenge.go</a>
	    <a href="../src/runtime/mgcstack.go.html">mgcstack.go</a>
	    <a href="../src/runtime/mgcsweep.go.html">mgcsweep.go</a>
	    <a href="../src/runtime/mgcsweepbuf.go.html">mgcsweepbuf.go</a>
	    <a href="../src/runtime/mgcwork.go.html">mgcwork.go</a>
	    <a href="../src/runtime/mheap.go.html">mheap.go</a>
	    <a href="../src/runtime/mpagealloc.go.html">mpagealloc.go</a>
	    <a href="../src/runtime/mpagealloc_64bit.go.html">mpagealloc_64bit.go</a>
	    <a href="../src/runtime/mpagecache.go.html">mpagecache.go</a>
	    <a href="../src/runtime/mpallocbits.go.html">mpallocbits.go</a>
	    <a href="../src/runtime/mprof.go.html">mprof.go</a>
	    <a href="../src/runtime/mranges.go.html">mranges.go</a>
	    <a href="../src/runtime/msan0.go.html">msan0.go</a>
	    <a href="../src/runtime/msize.go.html">msize.go</a>
	    <a href="../src/runtime/mspanset.go.html">mspanset.go</a>
	    <a href="../src/runtime/mstats.go.html">mstats.go</a>
	    <a href="../src/runtime/mwbbuf.go.html">mwbbuf.go</a>
	    <a href="../src/runtime/nbpipe_pipe2.go.html">nbpipe_pipe2.go</a>
	    <a href="../src/runtime/netpoll.go.html">netpoll.go</a>
	    <a href="../src/runtime/netpoll_epoll.go.html">netpoll_epoll.go</a>
	    <a href="../src/runtime/os_linux.go.html">os_linux.go</a>
	    <a href="../src/runtime/os_linux_generic.go.html">os_linux_generic.go</a>
	    <a href="../src/runtime/os_linux_noauxv.go.html">os_linux_noauxv.go</a>
	    <a href="../src/runtime/os_linux_x86.go.html">os_linux_x86.go</a>
	    <a href="../src/runtime/os_nonopenbsd.go.html">os_nonopenbsd.go</a>
	    <a href="../src/runtime/panic.go.html">panic.go</a>
	    <a href="../src/runtime/plugin.go.html">plugin.go</a>
	    <a href="../src/runtime/preempt.go.html">preempt.go</a>
	    <a href="../src/runtime/preempt_nonwindows.go.html">preempt_nonwindows.go</a>
	    <a href="../src/runtime/print.go.html">print.go</a>
	    <a href="../src/runtime/proc.go.html">proc.go</a>
	    <a href="../src/runtime/profbuf.go.html">profbuf.go</a>
	    <a href="../src/runtime/proflabel.go.html">proflabel.go</a>
	    <a href="../src/runtime/race0.go.html">race0.go</a>
	    <a href="../src/runtime/rdebug.go.html">rdebug.go</a>
	    <a href="../src/runtime/relax_stub.go.html">relax_stub.go</a>
	    <a href="../src/runtime/runtime.go.html">runtime.go</a>
	    <a href="../src/runtime/runtime1.go.html">runtime1.go</a>
	    <a href="../src/runtime/runtime2.go.html">runtime2.go</a>
	    <a href="../src/runtime/rwmutex.go.html">rwmutex.go</a>
	    <a href="../src/runtime/select.go.html">select.go</a>
	    <a href="../src/runtime/sema.go.html">sema.go</a>
	    <a href="../src/runtime/signal_amd64.go.html">signal_amd64.go</a>
	    <a href="../src/runtime/signal_linux_amd64.go.html">signal_linux_amd64.go</a>
	    <a href="../src/runtime/signal_unix.go.html">signal_unix.go</a>
	    <a href="../src/runtime/sigqueue.go.html">sigqueue.go</a>
	    <a href="../src/runtime/sigqueue_note.go.html">sigqueue_note.go</a>
	    <a href="../src/runtime/sigtab_linux_generic.go.html">sigtab_linux_generic.go</a>
	    <a href="../src/runtime/sizeclasses.go.html">sizeclasses.go</a>
	    <a href="../src/runtime/slice.go.html">slice.go</a>
	    <a href="../src/runtime/softfloat64.go.html">softfloat64.go</a>
	    <a href="../src/runtime/stack.go.html">stack.go</a>
	    <a href="../src/runtime/string.go.html">string.go</a>
	    <a href="../src/runtime/stubs.go.html">stubs.go</a>
	    <a href="../src/runtime/stubs2.go.html">stubs2.go</a>
	    <a href="../src/runtime/stubs3.go.html">stubs3.go</a>
	    <a href="../src/runtime/stubs_amd64.go.html">stubs_amd64.go</a>
	    <a href="../src/runtime/stubs_linux.go.html">stubs_linux.go</a>
	    <a href="../src/runtime/symtab.go.html">symtab.go</a>
	    <a href="../src/runtime/sys_nonppc64x.go.html">sys_nonppc64x.go</a>
	    <a href="../src/runtime/sys_x86.go.html">sys_x86.go</a>
	    <a href="../src/runtime/time.go.html">time.go</a>
	    <a href="../src/runtime/time_nofake.go.html">time_nofake.go</a>
	    <a href="../src/runtime/timestub.go.html">timestub.go</a>
	    <a href="../src/runtime/timestub2.go.html">timestub2.go</a>
	    <a href="../src/runtime/trace.go.html">trace.go</a>
	    <a href="../src/runtime/traceback.go.html">traceback.go</a>
	    <a href="../src/runtime/type.go.html">type.go</a>
	    <a href="../src/runtime/typekind.go.html">typekind.go</a>
	    <a href="../src/runtime/utf8.go.html">utf8.go</a>
	    <a href="../src/runtime/vdso_elf64.go.html">vdso_elf64.go</a>
	    <a href="../src/runtime/vdso_linux.go.html">vdso_linux.go</a>
	    <a href="../src/runtime/vdso_linux_amd64.go.html">vdso_linux_amd64.go</a>
	    <a href="../src/runtime/write_err.go.html">write_err.go</a>
	    <a href="../src/runtime/asm_ppc64x.h.html">asm_ppc64x.h</a>
	    <a href="../src/runtime/funcdata.h.html">funcdata.h</a>
	    <a href="../src/runtime/go_tls.h.html">go_tls.h</a>
	    <a href="../src/runtime/textflag.h.html">textflag.h</a>
	    <a href="../src/runtime/asm.s.html">asm.s</a>
	    <a href="../src/runtime/asm_amd64.s.html">asm_amd64.s</a>
	    <a href="../src/runtime/duff_amd64.s.html">duff_amd64.s</a>
	    <a href="../src/runtime/memclr_amd64.s.html">memclr_amd64.s</a>
	    <a href="../src/runtime/memmove_amd64.s.html">memmove_amd64.s</a>
	    <a href="../src/runtime/preempt_amd64.s.html">preempt_amd64.s</a>
	    <a href="../src/runtime/rt0_linux_amd64.s.html">rt0_linux_amd64.s</a>
	    <a href="../src/runtime/sys_linux_amd64.s.html">sys_linux_amd64.s</a>

<span class="title">Exported Type Names</span>

<div class="anchor" id="name-BlockProfileRecord" data-popularity="120">	<a href="../use/runtime..BlockProfileRecord.html">type</a> <a href="../src/runtime/mprof.go.html#line-621">BlockProfileRecord</a> <i>(struct)</i>
		BlockProfileRecord describes blocking events originated
		at a particular call sequence (stack trace).

		<input type='checkbox' class="stat" id="BlockProfileRecord-stat-fields"><label for="BlockProfileRecord-stat-fields">Exported Fields (4)</label><span id='BlockProfileRecord-stat-fields-content' class="stat-content">
			<span class="nodocs"><a href="../src/runtime/mprof.go.html#line-622">Count</a> <i><a href="builtin.html#name-int64">int64</a></i></span>
			<span class="nodocs"><a href="../src/runtime/mprof.go.html#line-623">Cycles</a> <i><a href="builtin.html#name-int64">int64</a></i></span>
			<span class="nodocs"><a href="../src/runtime/mprof.go.html#line-624">StackRecord</a> <i><a href="#name-StackRecord">StackRecord</a></i></span>
			<input type='checkbox' class="stat" id="BlockProfileRecord-stat-field-Stack0"><label for="BlockProfileRecord-stat-field-Stack0"><a href="../src/runtime/mprof.go.html#line-624" class="path-duplicate">StackRecord</a>.<a href="../src/runtime/mprof.go.html#line-465">Stack0</a> <i>[32]<a href="builtin.html#name-uintptr">uintptr</a></i></label><span id='BlockProfileRecord-stat-field-Stack0-content' class="stat-content">
				// stack trace for this record; ends at first 0 entry
</span></span>
		<input type='checkbox' class="stat" id="BlockProfileRecord-stat-methods"><label for="BlockProfileRecord-stat-methods">One Exported Method</label><span id='BlockProfileRecord-stat-methods-content' class="stat-content">
			<input type='checkbox' class="stat" id="BlockProfileRecord-stat-method-Stack"><label for="BlockProfileRecord-stat-method-Stack">(*T) <a href="../src/runtime/mprof.go.html#line-470">Stack</a>() []<a href="builtin.html#name-uintptr">uintptr</a></label><span id='BlockProfileRecord-stat-method-Stack-content' class="stat-content">
				Stack returns the stack trace associated with the record,
				a prefix of r.Stack0.
</span></span>
		<input type='checkbox' class="stat" id="BlockProfileRecord-stat-params"><label for="BlockProfileRecord-stat-params">As Inputs Of (2+)</label><span id='BlockProfileRecord-stat-params-content' class="stat-content">
			func <a href="#name-BlockProfile">BlockProfile</a>(p []<b>BlockProfileRecord</b>) (n <a href="builtin.html#name-int">int</a>, ok <a href="builtin.html#name-bool">bool</a>)
			func <a href="#name-MutexProfile">MutexProfile</a>(p []<b>BlockProfileRecord</b>) (n <a href="builtin.html#name-int">int</a>, ok <a href="builtin.html#name-bool">bool</a>)</span></div>
<div class="anchor" id="name-Error" data-popularity="300">	<a href="../use/runtime..Error.html">type</a> <a href="../src/runtime/error.go.html#line-10">Error</a> <b<i>(interface)</i></b>
		The Error interface identifies a run time error.

		<input type='checkbox' class="stat" id="Error-stat-methods"><label for="Error-stat-methods">Exported Methods (2)</label><span id='Error-stat-methods-content' class="stat-content">
			<span class="nodocs">( T) <a href="builtin.html#name-error">Error</a>() <a href="builtin.html">builtin</a>.<a href="../src/builtin/builtin.go.html#line-71">string</a></span>
			<input type='checkbox' class="stat" id="Error-stat-method-RuntimeError"><label for="Error-stat-method-RuntimeError">( T) <a href="../src/runtime/error.go.html#line-17">RuntimeError</a>()</label><span id='Error-stat-method-RuntimeError-content' class="stat-content">
				RuntimeError is a no-op function but
				serves to distinguish types that are run time
				errors from ordinary errors: a type is a
				run time error if it has a RuntimeError method.
</span></span>
		<input type='checkbox' class="stat" id="Error-stat-impledby"><label for="Error-stat-impledby">Implemented By (1+)</label><span id='Error-stat-impledby-content' class="stat-content">
			*<a href="#name-TypeAssertionError">TypeAssertionError</a></span>
		<input type='checkbox' class="stat" id="Error-stat-impls"><label for="Error-stat-impls">Implements (1+)</label><span id='Error-stat-impls-content' class="stat-content">
			 T : <a href="builtin.html#name-error">error</a></span></div>
<div class="anchor" id="name-Frame" data-popularity="75">	<a href="../use/runtime..Frame.html">type</a> <a href="../src/runtime/symtab.go.html#line-25">Frame</a> <i>(struct)</i>
		Frame is the information returned by Frames for each call frame.

		<input type='checkbox' class="stat" id="Frame-stat-fields"><label for="Frame-stat-fields">Exported Fields (6)</label><span id='Frame-stat-fields-content' class="stat-content">
			<input type='checkbox' class="stat" id="Frame-stat-field-Entry"><label for="Frame-stat-field-Entry"><a href="../src/runtime/symtab.go.html#line-54">Entry</a> <i><a href="builtin.html#name-uintptr">uintptr</a></i></label><span id='Frame-stat-field-Entry-content' class="stat-content">
				Entry point program counter for the function; may be zero
				if not known. If Func is not nil then Entry ==
				Func.Entry().
</span>
			<input type='checkbox' class="stat" id="Frame-stat-field-File"><label for="Frame-stat-field-File"><a href="../src/runtime/symtab.go.html#line-48">File</a> <i><a href="builtin.html#name-string">string</a></i></label><span id='Frame-stat-field-File-content' class="stat-content">
				File and Line are the file name and line number of the
				location in this frame. For non-leaf frames, this will be
				the location of a call. These may be the empty string and
				zero, respectively, if not known.
</span>
			<input type='checkbox' class="stat" id="Frame-stat-field-Func"><label for="Frame-stat-field-Func"><a href="../src/runtime/symtab.go.html#line-35">Func</a> <i>*<a href="#name-Func">Func</a></i></label><span id='Frame-stat-field-Func-content' class="stat-content">
				Func is the Func value of this call frame. This may be nil
				for non-Go code or fully inlined functions.
</span>
			<input type='checkbox' class="stat" id="Frame-stat-field-Function"><label for="Frame-stat-field-Function"><a href="../src/runtime/symtab.go.html#line-42">Function</a> <i><a href="builtin.html#name-string">string</a></i></label><span id='Frame-stat-field-Function-content' class="stat-content">
				Function is the package path-qualified function name of
				this call frame. If non-empty, this string uniquely
				identifies a single function in the program.
				This may be the empty string if not known.
				If Func is not nil then Function == Func.Name().
</span>
			<span class="nodocs"><a href="../src/runtime/symtab.go.html#line-49">Line</a> <i><a href="builtin.html#name-int">int</a></i></span>
			<input type='checkbox' class="stat" id="Frame-stat-field-PC"><label for="Frame-stat-field-PC"><a href="../src/runtime/symtab.go.html#line-31">PC</a> <i><a href="builtin.html#name-uintptr">uintptr</a></i></label><span id='Frame-stat-field-PC-content' class="stat-content">
				PC is the program counter for the location in this frame.
				For a frame that calls another frame, this will be the
				program counter of a call instruction. Because of inlining,
				multiple frames may have the same PC value, but different
				symbolic information.
</span></span>
		<input type='checkbox' class="stat" id="Frame-stat-results"><label for="Frame-stat-results">As Outputs Of (1+)</label><span id='Frame-stat-results-content' class="stat-content">
			func (*<a href="#name-Frames">Frames</a>).<a href="../src/runtime/symtab.go.html#line-73">Next</a>() (frame <b>Frame</b>, more <a href="builtin.html#name-bool">bool</a>)</span></div>
<div class="anchor" id="name-Frames" data-popularity="125">	<a href="../use/runtime..Frames.html">type</a> <a href="../src/runtime/symtab.go.html#line-15">Frames</a> <i>(struct)</i>
		Frames may be used to get function/file/line information for a
		slice of PC values returned by Callers.

		<input type='checkbox' class="stat" id="Frames-stat-methods"><label for="Frames-stat-methods">One Exported Method</label><span id='Frames-stat-methods-content' class="stat-content">
			<input type='checkbox' class="stat" id="Frames-stat-method-Next"><label for="Frames-stat-method-Next">(*T) <a href="../src/runtime/symtab.go.html#line-73">Next</a>() (frame <a href="#name-Frame">Frame</a>, more <a href="builtin.html#name-bool">bool</a>)</label><span id='Frames-stat-method-Next-content' class="stat-content">
				Next returns frame information for the next caller.
				If more is false, there are no more callers (the Frame value is valid).
</span></span>
		<input type='checkbox' class="stat" id="Frames-stat-results"><label for="Frames-stat-results">As Outputs Of (1+)</label><span id='Frames-stat-results-content' class="stat-content">
			func <a href="#name-CallersFrames">CallersFrames</a>(callers []<a href="builtin.html#name-uintptr">uintptr</a>) *<b>Frames</b></span></div>
<div class="anchor" id="name-Func" data-popularity="225">	<a href="../use/runtime..Func.html">type</a> <a href="../src/runtime/symtab.go.html#line-254">Func</a> <i>(struct)</i>
		A Func represents a Go function in the running binary.

		<input type='checkbox' class="stat" id="Func-stat-methods"><label for="Func-stat-methods">Exported Methods (3)</label><span id='Func-stat-methods-content' class="stat-content">
			<input type='checkbox' class="stat" id="Func-stat-method-Entry"><label for="Func-stat-method-Entry">(*T) <a href="../src/runtime/symtab.go.html#line-608">Entry</a>() <a href="builtin.html#name-uintptr">uintptr</a></label><span id='Func-stat-method-Entry-content' class="stat-content">
				Entry returns the entry address of the function.
</span>
			<input type='checkbox' class="stat" id="Func-stat-method-FileLine"><label for="Func-stat-method-FileLine">(*T) <a href="../src/runtime/symtab.go.html#line-621">FileLine</a>(pc <a href="builtin.html#name-uintptr">uintptr</a>) (file <a href="builtin.html#name-string">string</a>, line <a href="builtin.html#name-int">int</a>)</label><span id='Func-stat-method-FileLine-content' class="stat-content">
				FileLine returns the file name and line number of the
				source code corresponding to the program counter pc.
				The result will not be accurate if pc is not a program
				counter within f.
</span>
			<input type='checkbox' class="stat" id="Func-stat-method-Name"><label for="Func-stat-method-Name">(*T) <a href="../src/runtime/symtab.go.html#line-595">Name</a>() <a href="builtin.html#name-string">string</a></label><span id='Func-stat-method-Name-content' class="stat-content">
				Name returns the name of the function.
</span></span>
		<input type='checkbox' class="stat" id="Func-stat-results"><label for="Func-stat-results">As Outputs Of (1+)</label><span id='Func-stat-results-content' class="stat-content">
			func <a href="#name-FuncForPC">FuncForPC</a>(pc <a href="builtin.html#name-uintptr">uintptr</a>) *<b>Func</b></span></div>
<div class="anchor" id="name-MemProfileRecord" data-popularity="185">	<a href="../use/runtime..MemProfileRecord.html">type</a> <a href="../src/runtime/mprof.go.html#line-497">MemProfileRecord</a> <i>(struct)</i>
		A MemProfileRecord describes the live objects allocated
		by a particular call sequence (stack trace).

		<input type='checkbox' class="stat" id="MemProfileRecord-stat-fields"><label for="MemProfileRecord-stat-fields">Exported Fields (5)</label><span id='MemProfileRecord-stat-fields-content' class="stat-content">
			<input type='checkbox' class="stat" id="MemProfileRecord-stat-field-AllocBytes"><label for="MemProfileRecord-stat-field-AllocBytes"><a href="../src/runtime/mprof.go.html#line-498">AllocBytes</a> <i><a href="builtin.html#name-int64">int64</a></i></label><span id='MemProfileRecord-stat-field-AllocBytes-content' class="stat-content">
				// number of bytes allocated, freed
</span>
			<input type='checkbox' class="stat" id="MemProfileRecord-stat-field-AllocObjects"><label for="MemProfileRecord-stat-field-AllocObjects"><a href="../src/runtime/mprof.go.html#line-499">AllocObjects</a> <i><a href="builtin.html#name-int64">int64</a></i></label><span id='MemProfileRecord-stat-field-AllocObjects-content' class="stat-content">
				// number of objects allocated, freed
</span>
			<input type='checkbox' class="stat" id="MemProfileRecord-stat-field-FreeBytes"><label for="MemProfileRecord-stat-field-FreeBytes"><a href="../src/runtime/mprof.go.html#line-498">FreeBytes</a> <i><a href="builtin.html#name-int64">int64</a></i></label><span id='MemProfileRecord-stat-field-FreeBytes-content' class="stat-content">
				// number of bytes allocated, freed
</span>
			<input type='checkbox' class="stat" id="MemProfileRecord-stat-field-FreeObjects"><label for="MemProfileRecord-stat-field-FreeObjects"><a href="../src/runtime/mprof.go.html#line-499">FreeObjects</a> <i><a href="builtin.html#name-int64">int64</a></i></label><span id='MemProfileRecord-stat-field-FreeObjects-content' class="stat-content">
				// number of objects allocated, freed
</span>
			<input type='checkbox' class="stat" id="MemProfileRecord-stat-field-Stack0"><label for="MemProfileRecord-stat-field-Stack0"><a href="../src/runtime/mprof.go.html#line-500">Stack0</a> <i>[32]<a href="builtin.html#name-uintptr">uintptr</a></i></label><span id='MemProfileRecord-stat-field-Stack0-content' class="stat-content">
				// stack trace for this record; ends at first 0 entry
</span></span>
		<input type='checkbox' class="stat" id="MemProfileRecord-stat-methods"><label for="MemProfileRecord-stat-methods">Exported Methods (3)</label><span id='MemProfileRecord-stat-methods-content' class="stat-content">
			<input type='checkbox' class="stat" id="MemProfileRecord-stat-method-InUseBytes"><label for="MemProfileRecord-stat-method-InUseBytes">(*T) <a href="../src/runtime/mprof.go.html#line-504">InUseBytes</a>() <a href="builtin.html#name-int64">int64</a></label><span id='MemProfileRecord-stat-method-InUseBytes-content' class="stat-content">
				InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).
</span>
			<input type='checkbox' class="stat" id="MemProfileRecord-stat-method-InUseObjects"><label for="MemProfileRecord-stat-method-InUseObjects">(*T) <a href="../src/runtime/mprof.go.html#line-507">InUseObjects</a>() <a href="builtin.html#name-int64">int64</a></label><span id='MemProfileRecord-stat-method-InUseObjects-content' class="stat-content">
				InUseObjects returns the number of objects in use (AllocObjects - FreeObjects).
</span>
			<input type='checkbox' class="stat" id="MemProfileRecord-stat-method-Stack"><label for="MemProfileRecord-stat-method-Stack">(*T) <a href="../src/runtime/mprof.go.html#line-513">Stack</a>() []<a href="builtin.html#name-uintptr">uintptr</a></label><span id='MemProfileRecord-stat-method-Stack-content' class="stat-content">
				Stack returns the stack trace associated with the record,
				a prefix of r.Stack0.
</span></span>
		<input type='checkbox' class="stat" id="MemProfileRecord-stat-params"><label for="MemProfileRecord-stat-params">As Inputs Of (1+)</label><span id='MemProfileRecord-stat-params-content' class="stat-content">
			func <a href="#name-MemProfile">MemProfile</a>(p []<b>MemProfileRecord</b>, inuseZero <a href="builtin.html#name-bool">bool</a>) (n <a href="builtin.html#name-int">int</a>, ok <a href="builtin.html#name-bool">bool</a>)</span></div>
<div class="anchor" id="name-MemStats" data-popularity="35">	<a href="../use/runtime..MemStats.html">type</a> <a href="../src/runtime/mstats.go.html#line-150">MemStats</a> <i>(struct)</i>
		A MemStats records statistics about the memory allocator.

		<input type='checkbox' class="stat" id="MemStats-stat-fields"><label for="MemStats-stat-fields">Exported Fields (32)</label><span id='MemStats-stat-fields-content' class="stat-content">
			<input type='checkbox' class="stat" id="MemStats-stat-field-Alloc"><label for="MemStats-stat-field-Alloc"><a href="../src/runtime/mstats.go.html#line-156">Alloc</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-Alloc-content' class="stat-content">
				Alloc is bytes of allocated heap objects.

				This is the same as HeapAlloc (see below).
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-BuckHashSys"><label for="MemStats-stat-field-BuckHashSys"><a href="../src/runtime/mstats.go.html#line-323">BuckHashSys</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-BuckHashSys-content' class="stat-content">
				BuckHashSys is bytes of memory in profiling bucket hash tables.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-BySize"><label for="MemStats-stat-field-BySize"><a href="../src/runtime/mstats.go.html#line-405">BySize</a> <i>[61]struct{Size <a href="builtin.html#name-uint32">uint32</a>; Mallocs <a href="builtin.html#name-uint64">uint64</a>; Frees <a href="builtin.html#name-uint64">uint64</a>}</i></label><span id='MemStats-stat-field-BySize-content' class="stat-content">
				BySize reports per-size class allocation statistics.

				BySize[N] gives statistics for allocations of size S where
				BySize[N-1].Size &lt; S ≤ BySize[N].Size.

				This does not report allocations larger than BySize[60].Size.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-DebugGC"><label for="MemStats-stat-field-DebugGC"><a href="../src/runtime/mstats.go.html#line-397">DebugGC</a> <i><a href="builtin.html#name-bool">bool</a></i></label><span id='MemStats-stat-field-DebugGC-content' class="stat-content">
				DebugGC is currently unused.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-EnableGC"><label for="MemStats-stat-field-EnableGC"><a href="../src/runtime/mstats.go.html#line-394">EnableGC</a> <i><a href="builtin.html#name-bool">bool</a></i></label><span id='MemStats-stat-field-EnableGC-content' class="stat-content">
				EnableGC indicates that GC is enabled. It is always true,
				even if GOGC=off.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-Frees"><label for="MemStats-stat-field-Frees"><a href="../src/runtime/mstats.go.html#line-186">Frees</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-Frees-content' class="stat-content">
				Frees is the cumulative count of heap objects freed.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-GCCPUFraction"><label for="MemStats-stat-field-GCCPUFraction"><a href="../src/runtime/mstats.go.html#line-390">GCCPUFraction</a> <i><a href="builtin.html#name-float64">float64</a></i></label><span id='MemStats-stat-field-GCCPUFraction-content' class="stat-content">
				GCCPUFraction is the fraction of this program's available
				CPU time used by the GC since the program started.

				GCCPUFraction is expressed as a number between 0 and 1,
				where 0 means GC has consumed none of this program's CPU. A
				program's available CPU time is defined as the integral of
				GOMAXPROCS since the program started. That is, if
				GOMAXPROCS is 2 and a program has been running for 10
				seconds, its "available CPU" is 20 seconds. GCCPUFraction
				does not include CPU time used for write barrier activity.

				This is the same as the fraction of CPU reported by
				GODEBUG=gctrace=1.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-GCSys"><label for="MemStats-stat-field-GCSys"><a href="../src/runtime/mstats.go.html#line-326">GCSys</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-GCSys-content' class="stat-content">
				GCSys is bytes of memory in garbage collection metadata.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-HeapAlloc"><label for="MemStats-stat-field-HeapAlloc"><a href="../src/runtime/mstats.go.html#line-220">HeapAlloc</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-HeapAlloc-content' class="stat-content">
				HeapAlloc is bytes of allocated heap objects.

				"Allocated" heap objects include all reachable objects, as
				well as unreachable objects that the garbage collector has
				not yet freed. Specifically, HeapAlloc increases as heap
				objects are allocated and decreases as the heap is swept
				and unreachable objects are freed. Sweeping occurs
				incrementally between GC cycles, so these two processes
				occur simultaneously, and as a result HeapAlloc tends to
				change smoothly (in contrast with the sawtooth that is
				typical of stop-the-world garbage collectors).
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-HeapIdle"><label for="MemStats-stat-field-HeapIdle"><a href="../src/runtime/mstats.go.html#line-248">HeapIdle</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-HeapIdle-content' class="stat-content">
				HeapIdle is bytes in idle (unused) spans.

				Idle spans have no objects in them. These spans could be
				(and may already have been) returned to the OS, or they can
				be reused for heap allocations, or they can be reused as
				stack memory.

				HeapIdle minus HeapReleased estimates the amount of memory
				that could be returned to the OS, but is being retained by
				the runtime so it can grow the heap without requesting more
				memory from the OS. If this difference is significantly
				larger than the heap size, it indicates there was a recent
				transient spike in live heap size.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-HeapInuse"><label for="MemStats-stat-field-HeapInuse"><a href="../src/runtime/mstats.go.html#line-261">HeapInuse</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-HeapInuse-content' class="stat-content">
				HeapInuse is bytes in in-use spans.

				In-use spans have at least one object in them. These spans
				can only be used for other objects of roughly the same
				size.

				HeapInuse minus HeapAlloc estimates the amount of memory
				that has been dedicated to particular size classes, but is
				not currently being used. This is an upper bound on
				fragmentation, but in general this memory can be reused
				efficiently.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-HeapObjects"><label for="MemStats-stat-field-HeapObjects"><a href="../src/runtime/mstats.go.html#line-274">HeapObjects</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-HeapObjects-content' class="stat-content">
				HeapObjects is the number of allocated heap objects.

				Like HeapAlloc, this increases as objects are allocated and
				decreases as the heap is swept and unreachable objects are
				freed.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-HeapReleased"><label for="MemStats-stat-field-HeapReleased"><a href="../src/runtime/mstats.go.html#line-267">HeapReleased</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-HeapReleased-content' class="stat-content">
				HeapReleased is bytes of physical memory returned to the OS.

				This counts heap memory from idle spans that was returned
				to the OS and has not yet been reacquired for the heap.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-HeapSys"><label for="MemStats-stat-field-HeapSys"><a href="../src/runtime/mstats.go.html#line-233">HeapSys</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-HeapSys-content' class="stat-content">
				HeapSys is bytes of heap memory obtained from the OS.

				HeapSys measures the amount of virtual address space
				reserved for the heap. This includes virtual address space
				that has been reserved but not yet used, which consumes no
				physical memory, but tends to be small, as well as virtual
				address space for which the physical memory has been
				returned to the OS after it became unused (see HeapReleased
				for a measure of the latter).

				HeapSys estimates the largest size the heap has had.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-LastGC"><label for="MemStats-stat-field-LastGC"><a href="../src/runtime/mstats.go.html#line-344">LastGC</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-LastGC-content' class="stat-content">
				LastGC is the time the last garbage collection finished, as
				nanoseconds since 1970 (the UNIX epoch).
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-Lookups"><label for="MemStats-stat-field-Lookups"><a href="../src/runtime/mstats.go.html#line-179">Lookups</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-Lookups-content' class="stat-content">
				Lookups is the number of pointer lookups performed by the
				runtime.

				This is primarily useful for debugging runtime internals.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-MCacheInuse"><label for="MemStats-stat-field-MCacheInuse"><a href="../src/runtime/mstats.go.html#line-316">MCacheInuse</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-MCacheInuse-content' class="stat-content">
				MCacheInuse is bytes of allocated mcache structures.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-MCacheSys"><label for="MemStats-stat-field-MCacheSys"><a href="../src/runtime/mstats.go.html#line-320">MCacheSys</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-MCacheSys-content' class="stat-content">
				MCacheSys is bytes of memory obtained from the OS for
				mcache structures.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-MSpanInuse"><label for="MemStats-stat-field-MSpanInuse"><a href="../src/runtime/mstats.go.html#line-309">MSpanInuse</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-MSpanInuse-content' class="stat-content">
				MSpanInuse is bytes of allocated mspan structures.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-MSpanSys"><label for="MemStats-stat-field-MSpanSys"><a href="../src/runtime/mstats.go.html#line-313">MSpanSys</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-MSpanSys-content' class="stat-content">
				MSpanSys is bytes of memory obtained from the OS for mspan
				structures.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-Mallocs"><label for="MemStats-stat-field-Mallocs"><a href="../src/runtime/mstats.go.html#line-183">Mallocs</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-Mallocs-content' class="stat-content">
				Mallocs is the cumulative count of heap objects allocated.
				The number of live objects is Mallocs - Frees.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-NextGC"><label for="MemStats-stat-field-NextGC"><a href="../src/runtime/mstats.go.html#line-340">NextGC</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-NextGC-content' class="stat-content">
				NextGC is the target heap size of the next GC cycle.

				The garbage collector's goal is to keep HeapAlloc ≤ NextGC.
				At the end of each GC cycle, the target for the next cycle
				is computed based on the amount of reachable data and the
				value of GOGC.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-NumForcedGC"><label for="MemStats-stat-field-NumForcedGC"><a href="../src/runtime/mstats.go.html#line-375">NumForcedGC</a> <i><a href="builtin.html#name-uint32">uint32</a></i></label><span id='MemStats-stat-field-NumForcedGC-content' class="stat-content">
				NumForcedGC is the number of GC cycles that were forced by
				the application calling the GC function.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-NumGC"><label for="MemStats-stat-field-NumGC"><a href="../src/runtime/mstats.go.html#line-371">NumGC</a> <i><a href="builtin.html#name-uint32">uint32</a></i></label><span id='MemStats-stat-field-NumGC-content' class="stat-content">
				NumGC is the number of completed GC cycles.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-OtherSys"><label for="MemStats-stat-field-OtherSys"><a href="../src/runtime/mstats.go.html#line-330">OtherSys</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-OtherSys-content' class="stat-content">
				OtherSys is bytes of memory in miscellaneous off-heap
				runtime allocations.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-PauseEnd"><label for="MemStats-stat-field-PauseEnd"><a href="../src/runtime/mstats.go.html#line-368">PauseEnd</a> <i>[256]<a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-PauseEnd-content' class="stat-content">
				PauseEnd is a circular buffer of recent GC pause end times,
				as nanoseconds since 1970 (the UNIX epoch).

				This buffer is filled the same way as PauseNs. There may be
				multiple pauses per GC cycle; this records the end of the
				last pause in a cycle.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-PauseNs"><label for="MemStats-stat-field-PauseNs"><a href="../src/runtime/mstats.go.html#line-360">PauseNs</a> <i>[256]<a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-PauseNs-content' class="stat-content">
				PauseNs is a circular buffer of recent GC stop-the-world
				pause times in nanoseconds.

				The most recent pause is at PauseNs[(NumGC+255)%256]. In
				general, PauseNs[N%256] records the time paused in the most
				recent N%256th GC cycle. There may be multiple pauses per
				GC cycle; this is the sum of all pauses during a cycle.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-PauseTotalNs"><label for="MemStats-stat-field-PauseTotalNs"><a href="../src/runtime/mstats.go.html#line-351">PauseTotalNs</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-PauseTotalNs-content' class="stat-content">
				PauseTotalNs is the cumulative nanoseconds in GC
				stop-the-world pauses since the program started.

				During a stop-the-world pause, all goroutines are paused
				and only the garbage collector can run.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-StackInuse"><label for="MemStats-stat-field-StackInuse"><a href="../src/runtime/mstats.go.html#line-289">StackInuse</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-StackInuse-content' class="stat-content">
				StackInuse is bytes in stack spans.

				In-use stack spans have at least one stack in them. These
				spans can only be used for other stacks of the same size.

				There is no StackIdle because unused stack spans are
				returned to the heap (and hence counted toward HeapIdle).
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-StackSys"><label for="MemStats-stat-field-StackSys"><a href="../src/runtime/mstats.go.html#line-295">StackSys</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-StackSys-content' class="stat-content">
				StackSys is bytes of stack memory obtained from the OS.

				StackSys is StackInuse, plus any memory obtained directly
				from the OS for OS thread stacks (which should be minimal).
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-Sys"><label for="MemStats-stat-field-Sys"><a href="../src/runtime/mstats.go.html#line-173">Sys</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-Sys-content' class="stat-content">
				Sys is the total bytes of memory obtained from the OS.

				Sys is the sum of the XSys fields below. Sys measures the
				virtual address space reserved by the Go runtime for the
				heap, stacks, and other internal data structures. It's
				likely that not all of the virtual address space is backed
				by physical memory at any given moment, though in general
				it all was at some point.
</span>
			<input type='checkbox' class="stat" id="MemStats-stat-field-TotalAlloc"><label for="MemStats-stat-field-TotalAlloc"><a href="../src/runtime/mstats.go.html#line-163">TotalAlloc</a> <i><a href="builtin.html#name-uint64">uint64</a></i></label><span id='MemStats-stat-field-TotalAlloc-content' class="stat-content">
				TotalAlloc is cumulative bytes allocated for heap objects.

				TotalAlloc increases as heap objects are allocated, but
				unlike Alloc and HeapAlloc, it does not decrease when
				objects are freed.
</span></span>
		<input type='checkbox' class="stat" id="MemStats-stat-params"><label for="MemStats-stat-params">As Inputs Of (1+)</label><span id='MemStats-stat-params-content' class="stat-content">
			func <a href="#name-ReadMemStats">ReadMemStats</a>(m *<b>MemStats</b>)</span></div>
<div class="anchor" id="name-StackRecord" data-popularity="120">	<a href="../use/runtime..StackRecord.html">type</a> <a href="../src/runtime/mprof.go.html#line-464">StackRecord</a> <i>(struct)</i>
		A StackRecord describes a single execution stack.

		<input type='checkbox' class="stat" id="StackRecord-stat-fields"><label for="StackRecord-stat-fields">One Exported Field</label><span id='StackRecord-stat-fields-content' class="stat-content">
			<input type='checkbox' class="stat" id="StackRecord-stat-field-Stack0"><label for="StackRecord-stat-field-Stack0"><a href="../src/runtime/mprof.go.html#line-465">Stack0</a> <i>[32]<a href="builtin.html#name-uintptr">uintptr</a></i></label><span id='StackRecord-stat-field-Stack0-content' class="stat-content">
				// stack trace for this record; ends at first 0 entry
</span></span>
		<input type='checkbox' class="stat" id="StackRecord-stat-methods"><label for="StackRecord-stat-methods">One Exported Method</label><span id='StackRecord-stat-methods-content' class="stat-content">
			<input type='checkbox' class="stat" id="StackRecord-stat-method-Stack"><label for="StackRecord-stat-method-Stack">(*T) <a href="../src/runtime/mprof.go.html#line-470">Stack</a>() []<a href="builtin.html#name-uintptr">uintptr</a></label><span id='StackRecord-stat-method-Stack-content' class="stat-content">
				Stack returns the stack trace associated with the record,
				a prefix of r.Stack0.
</span></span>
		<input type='checkbox' class="stat" id="StackRecord-stat-params"><label for="StackRecord-stat-params">As Inputs Of (2+)</label><span id='StackRecord-stat-params-content' class="stat-content">
			func <a href="#name-GoroutineProfile">GoroutineProfile</a>(p []<b>StackRecord</b>) (n <a href="builtin.html#name-int">int</a>, ok <a href="builtin.html#name-bool">bool</a>)
			func <a href="#name-ThreadCreateProfile">ThreadCreateProfile</a>(p []<b>StackRecord</b>) (n <a href="builtin.html#name-int">int</a>, ok <a href="builtin.html#name-bool">bool</a>)</span></div>
<div class="anchor" id="name-TypeAssertionError" data-popularity="200">	<a href="../use/runtime..TypeAssertionError.html">type</a> <a href="../src/runtime/error.go.html#line-21">TypeAssertionError</a> <i>(struct)</i>
		A TypeAssertionError explains a failed type assertion.

		<input type='checkbox' class="stat" id="TypeAssertionError-stat-methods"><label for="TypeAssertionError-stat-methods">Exported Methods (2)</label><span id='TypeAssertionError-stat-methods-content' class="stat-content">
			<span class="nodocs">(*T) <a href="../src/runtime/error.go.html#line-30">Error</a>() <a href="builtin.html#name-string">string</a></span>
			<span class="nodocs">(*T) <a href="../src/runtime/error.go.html#line-28">RuntimeError</a>()</span></span>
		<input type='checkbox' class="stat" id="TypeAssertionError-stat-impls"><label for="TypeAssertionError-stat-impls">Implements (2+)</label><span id='TypeAssertionError-stat-impls-content' class="stat-content">
			*T : <a href="#name-Error">Error</a>
			*T : <a href="builtin.html#name-error">error</a></span></div>
<span class="title">Exported Values</span>

<div class="anchor" id="name-BlockProfile">	 <a href="../use/runtime..BlockProfile.html">func</a> <a href="../src/runtime/mprof.go.html#line-634">BlockProfile</a>(p []<a href="#name-BlockProfileRecord">BlockProfileRecord</a>) (n <a href="builtin.html#name-int">int</a>, ok <a href="builtin.html#name-bool">bool</a>)
		BlockProfile returns n, the number of records in the current blocking profile.
		If len(p) &gt;= n, BlockProfile copies the profile into p and returns n, true.
		If len(p) &lt; n, BlockProfile does not change p and returns n, false.

		Most clients should use the runtime/pprof package or
		the testing package's -test.blockprofile flag instead
		of calling BlockProfile directly.</div>
<div class="anchor" id="name-Breakpoint">	 <a href="../use/runtime..Breakpoint.html">func</a> <a href="../src/runtime/proc.go.html#line-3801">Breakpoint</a>()
		Breakpoint executes a breakpoint trap.</div>
<div class="anchor" id="name-Caller">	 <a href="../use/runtime..Caller.html">func</a> <a href="../src/runtime/extern.go.html#line-186">Caller</a>(skip <a href="builtin.html#name-int">int</a>) (pc <a href="builtin.html#name-uintptr">uintptr</a>, file <a href="builtin.html#name-string">string</a>, line <a href="builtin.html#name-int">int</a>, ok <a href="builtin.html#name-bool">bool</a>)
		Caller reports file and line number information about function invocations on
		the calling goroutine's stack. The argument skip is the number of stack frames
		to ascend, with 0 identifying the caller of Caller.  (For historical reasons the
		meaning of skip differs between Caller and Callers.) The return values report the
		program counter, file name, and line number within the file of the corresponding
		call. The boolean ok is false if it was not possible to recover the information.</div>
<div class="anchor" id="name-Callers">	 <a href="../use/runtime..Callers.html">func</a> <a href="../src/runtime/extern.go.html#line-209">Callers</a>(skip <a href="builtin.html#name-int">int</a>, pc []<a href="builtin.html#name-uintptr">uintptr</a>) <a href="builtin.html#name-int">int</a>
		Callers fills the slice pc with the return program counters of function invocations
		on the calling goroutine's stack. The argument skip is the number of stack frames
		to skip before recording in pc, with 0 identifying the frame for Callers itself and
		1 identifying the caller of Callers.
		It returns the number of entries written to pc.

		To translate these PCs into symbolic information such as function
		names and line numbers, use CallersFrames. CallersFrames accounts
		for inlined functions and adjusts the return program counters into
		call program counters. Iterating over the returned slice of PCs
		directly is discouraged, as is using FuncForPC on any of the
		returned PCs, since these cannot account for inlining or return
		program counter adjustment.</div>
<div class="anchor" id="name-CallersFrames">	 <a href="../use/runtime..CallersFrames.html">func</a> <a href="../src/runtime/symtab.go.html#line-65">CallersFrames</a>(callers []<a href="builtin.html#name-uintptr">uintptr</a>) *<a href="#name-Frames">Frames</a>
		CallersFrames takes a slice of PC values returned by Callers and
		prepares to return function/file/line information.
		Do not change the slice until you are done with the Frames.</div>
<div class="anchor" id="name-Compiler">	<a href="../use/runtime..Compiler.html">const</a> <a href="../src/runtime/compiler.go.html#line-13">Compiler</a> = "gc"
		Compiler is the name of the compiler toolchain that built the
		running binary. Known toolchains are:

			gc      Also known as cmd/compile.
			gccgo   The gccgo front end, part of the GCC compiler suite.</div>
<div class="anchor" id="name-CPUProfile">	 <a href="../use/runtime..CPUProfile.html">func</a> <a href="../src/runtime/cpuprof.go.html#line-188">CPUProfile</a>() []<a href="builtin.html#name-byte">byte</a>
		CPUProfile panics.
		It formerly provided raw access to chunks of
		a pprof-format profile generated by the runtime.
		The details of generating that format have changed,
		so this functionality has been removed.

		Deprecated: Use the runtime/pprof package,
		or the handlers in the net/http/pprof package,
		or the testing package's -test.cpuprofile flag instead.</div>
<div class="anchor" id="name-FuncForPC">	 <a href="../use/runtime..FuncForPC.html">func</a> <a href="../src/runtime/symtab.go.html#line-568">FuncForPC</a>(pc <a href="builtin.html#name-uintptr">uintptr</a>) *<a href="#name-Func">Func</a>
		FuncForPC returns a *Func describing the function that contains the
		given program counter address, or else nil.

		If pc represents multiple functions because of inlining, it returns
		the *Func describing the innermost function, but with an entry of
		the outermost function.</div>
<div class="anchor" id="name-GC">	 <a href="../use/runtime..GC.html">func</a> <a href="../src/runtime/mgc.go.html#line-1064">GC</a>()
		GC runs a garbage collection and blocks the caller until the
		garbage collection is complete. It may also block the entire
		program.</div>
<div class="anchor" id="name-GOARCH">	<a href="../use/runtime..GOARCH.html">const</a> <a href="../src/runtime/extern.go.html#line-244">GOARCH</a> <a href="builtin.html#name-string">string</a> = "amd64"
		GOARCH is the running program's architecture target:
		one of 386, amd64, arm, s390x, and so on.</div>
<div class="anchor" id="name-Goexit">	 <a href="../use/runtime..Goexit.html">func</a> <a href="../src/runtime/panic.go.html#line-583">Goexit</a>()
		Goexit terminates the goroutine that calls it. No other goroutine is affected.
		Goexit runs all deferred calls before terminating the goroutine. Because Goexit
		is not a panic, any recover calls in those deferred functions will return nil.

		Calling Goexit from the main goroutine terminates that goroutine
		without func main returning. Since func main has not returned,
		the program continues execution of other goroutines.
		If all other goroutines exit, the program crashes.</div>
<div class="anchor" id="name-GOMAXPROCS">	 <a href="../use/runtime..GOMAXPROCS.html">func</a> <a href="../src/runtime/debug.go.html#line-17">GOMAXPROCS</a>(n <a href="builtin.html#name-int">int</a>) <a href="builtin.html#name-int">int</a>
		GOMAXPROCS sets the maximum number of CPUs that can be executing
		simultaneously and returns the previous setting. If n &lt; 1, it does not
		change the current setting.
		The number of logical CPUs on the local machine can be queried with NumCPU.
		This call will go away when the scheduler improves.</div>
<div class="anchor" id="name-GOOS">	<a href="../use/runtime..GOOS.html">const</a> <a href="../src/runtime/extern.go.html#line-240">GOOS</a> <a href="builtin.html#name-string">string</a> = "linux"
		GOOS is the running program's operating system target:
		one of darwin, freebsd, linux, and so on.
		To view possible combinations of GOOS and GOARCH, run "go tool dist list".</div>
<div class="anchor" id="name-GOROOT">	 <a href="../use/runtime..GOROOT.html">func</a> <a href="../src/runtime/extern.go.html#line-222">GOROOT</a>() <a href="builtin.html#name-string">string</a>
		GOROOT returns the root of the Go tree. It uses the
		GOROOT environment variable, if set at process start,
		or else the root used during the Go build.</div>
<div class="anchor" id="name-GoroutineProfile">	 <a href="../use/runtime..GoroutineProfile.html">func</a> <a href="../src/runtime/mprof.go.html#line-787">GoroutineProfile</a>(p []<a href="#name-StackRecord">StackRecord</a>) (n <a href="builtin.html#name-int">int</a>, ok <a href="builtin.html#name-bool">bool</a>)
		GoroutineProfile returns n, the number of records in the active goroutine stack profile.
		If len(p) &gt;= n, GoroutineProfile copies the profile into p and returns n, true.
		If len(p) &lt; n, GoroutineProfile does not change p and returns n, false.

		Most clients should use the runtime/pprof package instead
		of calling GoroutineProfile directly.</div>
<div class="anchor" id="name-Gosched">	 <a href="../use/runtime..Gosched.html">func</a> <a href="../src/runtime/proc.go.html#line-269">Gosched</a>()
		Gosched yields the processor, allowing other goroutines to run. It does not
		suspend the current goroutine, so execution resumes automatically.</div>
<div class="anchor" id="name-KeepAlive">	 <a href="../use/runtime..KeepAlive.html">func</a> <a href="../src/runtime/mfinal.go.html#line-446">KeepAlive</a>(x interface{})
		KeepAlive marks its argument as currently reachable.
		This ensures that the object is not freed, and its finalizer is not run,
		before the point in the program where KeepAlive is called.

		A very simplified example showing where KeepAlive is required:
			type File struct { d int }
			d, err := syscall.Open("/file/path", syscall.O_RDONLY, 0)
			// ... do something if err != nil ...
			p := &amp;File{d}
			runtime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })
			var buf [10]byte
			n, err := syscall.Read(p.d, buf[:])
			// Ensure p is not finalized until Read returns.
			runtime.KeepAlive(p)
			// No more uses of p after this point.

		Without the KeepAlive call, the finalizer could run at the start of
		syscall.Read, closing the file descriptor before syscall.Read makes
		the actual system call.</div>
<div class="anchor" id="name-LockOSThread">	 <a href="../use/runtime..LockOSThread.html">func</a> <a href="../src/runtime/proc.go.html#line-3834">LockOSThread</a>()
		LockOSThread wires the calling goroutine to its current operating system thread.
		The calling goroutine will always execute in that thread,
		and no other goroutine will execute in it,
		until the calling goroutine has made as many calls to
		UnlockOSThread as to LockOSThread.
		If the calling goroutine exits without unlocking the thread,
		the thread will be terminated.

		All init functions are run on the startup thread. Calling LockOSThread
		from an init function will cause the main function to be invoked on
		that thread.

		A goroutine should call LockOSThread before calling OS services or
		non-Go library functions that depend on per-thread state.</div>
<div class="anchor" id="name-MemProfile">	 <a href="../use/runtime..MemProfile.html">func</a> <a href="../src/runtime/mprof.go.html#line-543">MemProfile</a>(p []<a href="#name-MemProfileRecord">MemProfileRecord</a>, inuseZero <a href="builtin.html#name-bool">bool</a>) (n <a href="builtin.html#name-int">int</a>, ok <a href="builtin.html#name-bool">bool</a>)
		MemProfile returns a profile of memory allocated and freed per allocation
		site.

		MemProfile returns n, the number of records in the current memory profile.
		If len(p) &gt;= n, MemProfile copies the profile into p and returns n, true.
		If len(p) &lt; n, MemProfile does not change p and returns n, false.

		If inuseZero is true, the profile includes allocation records
		where r.AllocBytes &gt; 0 but r.AllocBytes == r.FreeBytes.
		These are sites where memory was allocated, but it has all
		been released back to the runtime.

		The returned profile may be up to two garbage collection cycles old.
		This is to avoid skewing the profile toward allocations; because
		allocations happen in real time but frees are delayed until the garbage
		collector performs sweeping, the profile only accounts for allocations
		that have had a chance to be freed by the garbage collector.

		Most clients should use the runtime/pprof package or
		the testing package's -test.memprofile flag instead
		of calling MemProfile directly.</div>
<div class="anchor" id="name-MemProfileRate">	  <a href="../use/runtime..MemProfileRate.html">var</a> <a href="../src/runtime/mprof.go.html#line-493">MemProfileRate</a> <a href="builtin.html#name-int">int</a>
		MemProfileRate controls the fraction of memory allocations
		that are recorded and reported in the memory profile.
		The profiler aims to sample an average of
		one allocation per MemProfileRate bytes allocated.

		To include every allocated block in the profile, set MemProfileRate to 1.
		To turn off profiling entirely, set MemProfileRate to 0.

		The tools that process the memory profiles assume that the
		profile rate is constant across the lifetime of the program
		and equal to the current value. Programs that change the
		memory profiling rate should do so just once, as early as
		possible in the execution of the program (for example,
		at the beginning of main).</div>
<div class="anchor" id="name-MutexProfile">	 <a href="../use/runtime..MutexProfile.html">func</a> <a href="../src/runtime/mprof.go.html#line-669">MutexProfile</a>(p []<a href="#name-BlockProfileRecord">BlockProfileRecord</a>) (n <a href="builtin.html#name-int">int</a>, ok <a href="builtin.html#name-bool">bool</a>)
		MutexProfile returns n, the number of records in the current mutex profile.
		If len(p) &gt;= n, MutexProfile copies the profile into p and returns n, true.
		Otherwise, MutexProfile does not change p, and returns n, false.

		Most clients should use the runtime/pprof package
		instead of calling MutexProfile directly.</div>
<div class="anchor" id="name-NumCgoCall">	 <a href="../use/runtime..NumCgoCall.html">func</a> <a href="../src/runtime/debug.go.html#line-48">NumCgoCall</a>() <a href="builtin.html#name-int64">int64</a>
		NumCgoCall returns the number of cgo calls made by the current process.</div>
<div class="anchor" id="name-NumCPU">	 <a href="../use/runtime..NumCPU.html">func</a> <a href="../src/runtime/debug.go.html#line-43">NumCPU</a>() <a href="builtin.html#name-int">int</a>
		NumCPU returns the number of logical CPUs usable by the current process.

		The set of available CPUs is checked by querying the operating system
		at process startup. Changes to operating system CPU allocation after
		process startup are not reflected.</div>
<div class="anchor" id="name-NumGoroutine">	 <a href="../use/runtime..NumGoroutine.html">func</a> <a href="../src/runtime/debug.go.html#line-57">NumGoroutine</a>() <a href="builtin.html#name-int">int</a>
		NumGoroutine returns the number of goroutines that currently exist.</div>
<div class="anchor" id="name-ReadMemStats">	 <a href="../use/runtime..ReadMemStats.html">func</a> <a href="../src/runtime/mstats.go.html#line-448">ReadMemStats</a>(m *<a href="#name-MemStats">MemStats</a>)
		ReadMemStats populates m with memory allocator statistics.

		The returned memory allocator statistics are up to date as of the
		call to ReadMemStats. This is in contrast with a heap profile,
		which is a snapshot as of the most recently completed garbage
		collection cycle.</div>
<div class="anchor" id="name-ReadTrace">	 <a href="../use/runtime..ReadTrace.html">func</a> <a href="../src/runtime/trace.go.html#line-375">ReadTrace</a>() []<a href="builtin.html#name-byte">byte</a>
		ReadTrace returns the next chunk of binary tracing data, blocking until data
		is available. If tracing is turned off and all the data accumulated while it
		was on has been returned, ReadTrace returns nil. The caller must copy the
		returned data before calling ReadTrace again.
		ReadTrace must be called from one goroutine at a time.</div>
<div class="anchor" id="name-SetBlockProfileRate">	 <a href="../use/runtime..SetBlockProfileRate.html">func</a> <a href="../src/runtime/mprof.go.html#line-380">SetBlockProfileRate</a>(rate <a href="builtin.html#name-int">int</a>)
		SetBlockProfileRate controls the fraction of goroutine blocking events
		that are reported in the blocking profile. The profiler aims to sample
		an average of one blocking event per rate nanoseconds spent blocked.

		To include every blocking event in the profile, pass rate = 1.
		To turn off profiling entirely, pass rate &lt;= 0.</div>
<div class="anchor" id="name-SetCgoTraceback">	 <a href="../use/runtime..SetCgoTraceback.html">func</a> <a href="../src/runtime/traceback.go.html#line-1204">SetCgoTraceback</a>(version <a href="builtin.html#name-int">int</a>, traceback, context, symbolizer <a href="unsafe.html">unsafe</a>.<a href="unsafe.html#name-Pointer">Pointer</a>)
		SetCgoTraceback records three C functions to use to gather
		traceback information from C code and to convert that traceback
		information into symbolic information. These are used when printing
		stack traces for a program that uses cgo.

		The traceback and context functions may be called from a signal
		handler, and must therefore use only async-signal safe functions.
		The symbolizer function may be called while the program is
		crashing, and so must be cautious about using memory.  None of the
		functions may call back into Go.

		The context function will be called with a single argument, a
		pointer to a struct:

			struct {
				Context uintptr
			}

		In C syntax, this struct will be

			struct {
				uintptr_t Context;
			};

		If the Context field is 0, the context function is being called to
		record the current traceback context. It should record in the
		Context field whatever information is needed about the current
		point of execution to later produce a stack trace, probably the
		stack pointer and PC. In this case the context function will be
		called from C code.

		If the Context field is not 0, then it is a value returned by a
		previous call to the context function. This case is called when the
		context is no longer needed; that is, when the Go code is returning
		to its C code caller. This permits the context function to release
		any associated resources.

		While it would be correct for the context function to record a
		complete a stack trace whenever it is called, and simply copy that
		out in the traceback function, in a typical program the context
		function will be called many times without ever recording a
		traceback for that context. Recording a complete stack trace in a
		call to the context function is likely to be inefficient.

		The traceback function will be called with a single argument, a
		pointer to a struct:

			struct {
				Context    uintptr
				SigContext uintptr
				Buf        *uintptr
				Max        uintptr
			}

		In C syntax, this struct will be

			struct {
				uintptr_t  Context;
				uintptr_t  SigContext;
				uintptr_t* Buf;
				uintptr_t  Max;
			};

		The Context field will be zero to gather a traceback from the
		current program execution point. In this case, the traceback
		function will be called from C code.

		Otherwise Context will be a value previously returned by a call to
		the context function. The traceback function should gather a stack
		trace from that saved point in the program execution. The traceback
		function may be called from an execution thread other than the one
		that recorded the context, but only when the context is known to be
		valid and unchanging. The traceback function may also be called
		deeper in the call stack on the same thread that recorded the
		context. The traceback function may be called multiple times with
		the same Context value; it will usually be appropriate to cache the
		result, if possible, the first time this is called for a specific
		context value.

		If the traceback function is called from a signal handler on a Unix
		system, SigContext will be the signal context argument passed to
		the signal handler (a C ucontext_t* cast to uintptr_t). This may be
		used to start tracing at the point where the signal occurred. If
		the traceback function is not called from a signal handler,
		SigContext will be zero.

		Buf is where the traceback information should be stored. It should
		be PC values, such that Buf[0] is the PC of the caller, Buf[1] is
		the PC of that function's caller, and so on.  Max is the maximum
		number of entries to store.  The function should store a zero to
		indicate the top of the stack, or that the caller is on a different
		stack, presumably a Go stack.

		Unlike runtime.Callers, the PC values returned should, when passed
		to the symbolizer function, return the file/line of the call
		instruction.  No additional subtraction is required or appropriate.

		On all platforms, the traceback function is invoked when a call from
		Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,
		and freebsd/amd64, the traceback function is also invoked when a
		signal is received by a thread that is executing a cgo call. The
		traceback function should not make assumptions about when it is
		called, as future versions of Go may make additional calls.

		The symbolizer function will be called with a single argument, a
		pointer to a struct:

			struct {
				PC      uintptr // program counter to fetch information for
				File    *byte   // file name (NUL terminated)
				Lineno  uintptr // line number
				Func    *byte   // function name (NUL terminated)
				Entry   uintptr // function entry point
				More    uintptr // set non-zero if more info for this PC
				Data    uintptr // unused by runtime, available for function
			}

		In C syntax, this struct will be

			struct {
				uintptr_t PC;
				char*     File;
				uintptr_t Lineno;
				char*     Func;
				uintptr_t Entry;
				uintptr_t More;
				uintptr_t Data;
			};

		The PC field will be a value returned by a call to the traceback
		function.

		The first time the function is called for a particular traceback,
		all the fields except PC will be 0. The function should fill in the
		other fields if possible, setting them to 0/nil if the information
		is not available. The Data field may be used to store any useful
		information across calls. The More field should be set to non-zero
		if there is more information for this PC, zero otherwise. If More
		is set non-zero, the function will be called again with the same
		PC, and may return different information (this is intended for use
		with inlined functions). If More is zero, the function will be
		called with the next PC value in the traceback. When the traceback
		is complete, the function will be called once more with PC set to
		zero; this may be used to free any information. Each call will
		leave the fields of the struct set to the same values they had upon
		return, except for the PC field when the More field is zero. The
		function must not keep a copy of the struct pointer between calls.

		When calling SetCgoTraceback, the version argument is the version
		number of the structs that the functions expect to receive.
		Currently this must be zero.

		The symbolizer function may be nil, in which case the results of
		the traceback function will be displayed as numbers. If the
		traceback function is nil, the symbolizer function will never be
		called. The context function may be nil, in which case the
		traceback function will only be called with the context field set
		to zero.  If the context function is nil, then calls from Go to C
		to Go will not show a traceback for the C portion of the call stack.

		SetCgoTraceback should be called only once, ideally from an init function.</div>
<div class="anchor" id="name-SetCPUProfileRate">	 <a href="../use/runtime..SetCPUProfileRate.html">func</a> <a href="../src/runtime/cpuprof.go.html#line-54">SetCPUProfileRate</a>(hz <a href="builtin.html#name-int">int</a>)
		SetCPUProfileRate sets the CPU profiling rate to hz samples per second.
		If hz &lt;= 0, SetCPUProfileRate turns off profiling.
		If the profiler is on, the rate cannot be changed without first turning it off.

		Most clients should use the runtime/pprof package or
		the testing package's -test.cpuprofile flag instead of calling
		SetCPUProfileRate directly.</div>
<div class="anchor" id="name-SetFinalizer">	 <a href="../use/runtime..SetFinalizer.html">func</a> <a href="../src/runtime/mfinal.go.html#line-309">SetFinalizer</a>(obj interface{}, finalizer interface{})
		SetFinalizer sets the finalizer associated with obj to the provided
		finalizer function. When the garbage collector finds an unreachable block
		with an associated finalizer, it clears the association and runs
		finalizer(obj) in a separate goroutine. This makes obj reachable again,
		but now without an associated finalizer. Assuming that SetFinalizer
		is not called again, the next time the garbage collector sees
		that obj is unreachable, it will free obj.

		SetFinalizer(obj, nil) clears any finalizer associated with obj.

		The argument obj must be a pointer to an object allocated by calling
		new, by taking the address of a composite literal, or by taking the
		address of a local variable.
		The argument finalizer must be a function that takes a single argument
		to which obj's type can be assigned, and can have arbitrary ignored return
		values. If either of these is not true, SetFinalizer may abort the
		program.

		Finalizers are run in dependency order: if A points at B, both have
		finalizers, and they are otherwise unreachable, only the finalizer
		for A runs; once A is freed, the finalizer for B can run.
		If a cyclic structure includes a block with a finalizer, that
		cycle is not guaranteed to be garbage collected and the finalizer
		is not guaranteed to run, because there is no ordering that
		respects the dependencies.

		The finalizer is scheduled to run at some arbitrary time after the
		program can no longer reach the object to which obj points.
		There is no guarantee that finalizers will run before a program exits,
		so typically they are useful only for releasing non-memory resources
		associated with an object during a long-running program.
		For example, an os.File object could use a finalizer to close the
		associated operating system file descriptor when a program discards
		an os.File without calling Close, but it would be a mistake
		to depend on a finalizer to flush an in-memory I/O buffer such as a
		bufio.Writer, because the buffer would not be flushed at program exit.

		It is not guaranteed that a finalizer will run if the size of *obj is
		zero bytes.

		It is not guaranteed that a finalizer will run for objects allocated
		in initializers for package-level variables. Such objects may be
		linker-allocated, not heap-allocated.

		A finalizer may run as soon as an object becomes unreachable.
		In order to use finalizers correctly, the program must ensure that
		the object is reachable until it is no longer required.
		Objects stored in global variables, or that can be found by tracing
		pointers from a global variable, are reachable. For other objects,
		pass the object to a call of the KeepAlive function to mark the
		last point in the function where the object must be reachable.

		For example, if p points to a struct that contains a file descriptor d,
		and p has a finalizer that closes that file descriptor, and if the last
		use of p in a function is a call to syscall.Write(p.d, buf, size), then
		p may be unreachable as soon as the program enters syscall.Write. The
		finalizer may run at that moment, closing p.d, causing syscall.Write
		to fail because it is writing to a closed file descriptor (or, worse,
		to an entirely different file descriptor opened by a different goroutine).
		To avoid this problem, call runtime.KeepAlive(p) after the call to
		syscall.Write.

		A single goroutine runs all finalizers for a program, sequentially.
		If a finalizer must run for a long time, it should do so by starting
		a new goroutine.</div>
<div class="anchor" id="name-SetMutexProfileFraction">	 <a href="../use/runtime..SetMutexProfileFraction.html">func</a> <a href="../src/runtime/mprof.go.html#line-439">SetMutexProfileFraction</a>(rate <a href="builtin.html#name-int">int</a>) <a href="builtin.html#name-int">int</a>
		SetMutexProfileFraction controls the fraction of mutex contention events
		that are reported in the mutex profile. On average 1/rate events are
		reported. The previous rate is returned.

		To turn off profiling entirely, pass rate 0.
		To just read the current rate, pass rate &lt; 0.
		(For n&gt;1 the details of sampling may change.)</div>
<div class="anchor" id="name-Stack">	 <a href="../use/runtime..Stack.html">func</a> <a href="../src/runtime/mprof.go.html#line-803">Stack</a>(buf []<a href="builtin.html#name-byte">byte</a>, all <a href="builtin.html#name-bool">bool</a>) <a href="builtin.html#name-int">int</a>
		Stack formats a stack trace of the calling goroutine into buf
		and returns the number of bytes written to buf.
		If all is true, Stack formats stack traces of all other goroutines
		into buf after the trace for the current goroutine.</div>
<div class="anchor" id="name-StartTrace">	 <a href="../use/runtime..StartTrace.html">func</a> <a href="../src/runtime/trace.go.html#line-182">StartTrace</a>() <a href="builtin.html#name-error">error</a>
		StartTrace enables tracing for the current process.
		While tracing, the data will be buffered and available via ReadTrace.
		StartTrace returns an error if tracing is already enabled.
		Most clients should use the runtime/trace package or the testing package's
		-test.trace flag instead of calling StartTrace directly.</div>
<div class="anchor" id="name-StopTrace">	 <a href="../use/runtime..StopTrace.html">func</a> <a href="../src/runtime/trace.go.html#line-282">StopTrace</a>()
		StopTrace stops tracing, if it was previously enabled.
		StopTrace only returns after all the reads for the trace have completed.</div>
<div class="anchor" id="name-ThreadCreateProfile">	 <a href="../use/runtime..ThreadCreateProfile.html">func</a> <a href="../src/runtime/mprof.go.html#line-698">ThreadCreateProfile</a>(p []<a href="#name-StackRecord">StackRecord</a>) (n <a href="builtin.html#name-int">int</a>, ok <a href="builtin.html#name-bool">bool</a>)
		ThreadCreateProfile returns n, the number of records in the thread creation profile.
		If len(p) &gt;= n, ThreadCreateProfile copies the profile into p and returns n, true.
		If len(p) &lt; n, ThreadCreateProfile does not change p and returns n, false.

		Most clients should use the runtime/pprof package instead
		of calling ThreadCreateProfile directly.</div>
<div class="anchor" id="name-UnlockOSThread">	 <a href="../use/runtime..UnlockOSThread.html">func</a> <a href="../src/runtime/proc.go.html#line-3886">UnlockOSThread</a>()
		UnlockOSThread undoes an earlier call to LockOSThread.
		If this drops the number of active LockOSThread calls on the
		calling goroutine to zero, it unwires the calling goroutine from
		its fixed operating system thread.
		If there are no active LockOSThread calls, this is a no-op.

		Before calling UnlockOSThread, the caller must ensure that the OS
		thread is suitable for running other goroutines. If the caller made
		any permanent changes to the state of the thread that would affect
		other goroutines, it should not call this function and thus leave
		the goroutine locked to the OS thread until the goroutine (and
		hence the thread) exits.</div>
<div class="anchor" id="name-Version">	 <a href="../use/runtime..Version.html">func</a> <a href="../src/runtime/extern.go.html#line-233">Version</a>() <a href="builtin.html#name-string">string</a>
		Version returns the Go tree's version string.
		It is either the commit hash and date at the time of the build or,
		when possible, a release tag like "go1.3".</div></code></pre><pre id="footer">
<table><tr><td><img src="../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.8-preview</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>